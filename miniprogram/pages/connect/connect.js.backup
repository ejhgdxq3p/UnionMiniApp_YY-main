/**
 * 连接页面 - connect.js
 * 
 * 功能说明：
 * 1. 黑胶唱片风格的主题浏览界面
 * 2. 四个主题卡片列表，支持滑动切换
 * 3. 支持触摸滑动、惯性滚动和振动反馈
 * 4. 主题详情查看和介绍展示
 * 
 * 交互设计要点：
 * - 唱片旋转动画：模拟黑胶唱片播放效果
 * - 卡片滚动与缩放：滑动时实现卡片放大聚焦视觉效果
 * - 触摸振动反馈：滑动切换卡片时提供轻微振动
 * - 惯性滚动效果：根据滑动速度实现自然的惯性滑动
 * - 卡片位置偏移：将选中的卡片位置优化到视觉中心
 * 
 * 修改历史：
 * 1. 优化了卡片显示样式，使卡片更大更醒目
 * 2. 将头像改为方形，类似黑胶唱片的专辑封面
 * 3. 移除了选择指示器，简化界面
 * 4. 优化了滚动体验，提升用户交互感
 * 5. 将用户名片改为四个主题展示
 */

// miniprogram/pages/connect/connect.js
Page({

  /**
   * Page initial data
   */
  data: {
    arcPosition: 0,         // 弧形位置参数
    notesHeight: 120,       // 注释区域高度
    minNotesHeight: 200,    // 最小注释区域高度
    maxNotesHeight: 1200,   // 最大注释区域高度
    isExpanded: false,      // 是否展开注释区域
    startY: 0,              // 触摸起始Y坐标
    lastY: 0,               // 上次触摸Y坐标
    moveDirection: '',      // 移动方向
    moveSpeed: 0,           // 移动速度
    canScroll: false,       // 是否可以滚动
    isDragging: false,      // 是否正在拖动
    cards: [],              // 主题卡片数据
    isLoading: false,       // 是否正在加载
    loadError: '',          // 加载错误信息
    notes: [                // 注释数据
      { id: 1, title: '时间的使用者', content: '探索时间管理与生活节奏的艺术' },
      { id: 2, title: '感官交界', content: '体验多感官融合的奇妙世界' },
      { id: 3, title: '未来探索派', content: '畅想科技与人文的未来图景' },
      { id: 4, title: '探索人格博弈馆', content: '深入了解人格类型与社交动态' }
    ],
    linkBall1Angle: -60,    // 连接球1角度
    linkBall2Angle: 30,     // 连接球2角度
    linkBall3Angle: 270,    // 连接球3角度
    discRotation: 0,        // 唱片旋转角度
    currentTrackIndex: 0,   // 当前选中的主题索引
    startTouchY: 0,         // 触摸开始Y坐标
    lastTouchY: 0,          // 上次触摸Y坐标
    scrollDistance: 0,      // 滚动距离
    scrollOffset: 0,        // 滚动偏移量
    itemHeight: 310,        // 卡片高度
    touchStartTime: 0,      // 触摸开始时间
    touchEndTime: 0,        // 触摸结束时间
    touchVelocity: 0,       // 触摸滑动速度
    isScrolling: false,     // 是否正在滚动
    inertiaAnimationId: null, // 惯性动画ID
    isInertiaScrolling: false, // 是否正在惯性滚动
    showCardPreview: false, // 是否显示主题预览
    selectedCard: {},       // 选中的主题数据
    stars: [],              // 背景星星数组
    connections: [],        // 社交连接数据
    loading: false,         // 是否正在加载
    cardPositionOffset: 200, // 卡片位置偏移量
    pairResults: {},        // 存储每个主题下的配对结果 { themeId: [{users: [userA, userB], reason: "..."}, ...] }
    myPairs: [],            // 当前用户在当前主题下的配对对象
    myPairReasons: {},      // 当前用户与配对对象的理由 { openid: reason }
    showPairModal: false,    // 是否显示配对理由弹窗
    pairModalContent: '',    // 配对理由内容
    pairModalUser: null,     // 当前弹窗的配对用户
    // 新增：社群分类相关数据
    classificationData: [], // class_bar数据库的完整分类数据
    currentUserOpenid: '',  // 当前用户的openid
    themeCommunitiesData: {}, // 当前主题下的社群数据
    currentUserCommunity: null, // 当前用户所在的社群
    communityMembers: [],    // 当前用户社群的其他成员
    // 照抄briefing页面的成功数据结构
    classifications: [],     // briefing页面的分类数据结构
    currentUserOpenId: '',   // briefing页面的openid字段
    // 详细名片相关数据
    showDetailedCard: false, // 是否显示详细名片弹窗
    selectedMember: {},      // 选中的成员数据
    // 配对相关数据
    hasPairedUsers: false,   // 是否已有配对用户
    pairType: '',           // 配对类型：'已配对', 'AI配对', '社群成员'
    pairReason: ''          // 配对理由
  },

  /**
   * Lifecycle function--Called when page load
   */
  onLoad(options) {
    // 初始化设置向上偏移量
    this.setData({
      cardPositionOffset: -200, // 向上偏移200rpx，使用负值
      scrollOffset: -200 // 设置初始滚动位置，与偏移量保持一致
    });
    
    this.initThemeCards();
    this.generateStars();
    this.initAnimation();
    
    // 【照抄briefing成功方案】直接调用分类函数，它会处理所有后续逻辑
    this.classifyUsers();
  },

  /**
   * Lifecycle function--Called when page is initially rendered
   */
  onReady() {
    // 添加向上偏移量，使选中的卡片位置更靠上
    this.setData({
      cardPositionOffset: -200 // 向上偏移200rpx
    });
  },

  /**
   * Lifecycle function--Called when page show
   */
  onShow() {
    if (typeof this.getTabBar === 'function' && this.getTabBar()) {
      this.getTabBar().updateSelected('/pages/connect/connect');
    }
    if (!this.rotationTimer) {
      this.startDiscRotation();
    }
  },

  /**
   * Lifecycle function--Called when page hide
   */
  onHide() {
    this.clearAllTimers();
  },

  /**
   * Lifecycle function--Called when page unload
   */
  onUnload() {
    this.clearAllTimers();
  },

  /**
   * Page event handler function--Called when user drop down
   */
  onPullDownRefresh() {

  },

  /**
   * Called when page reach bottom
   */
  onReachBottom() {

  },

  /**
   * Called when user click on the top right corner to share
   */
  onShareAppMessage() {

  },

  /**
   * 清除所有计时器
   */
  clearAllTimers: function() {
    if (this.rotationTimer) {
      clearInterval(this.rotationTimer);
      this.rotationTimer = null;
    }
    if (this.scrollAnimationTimer) {
      clearTimeout(this.scrollAnimationTimer);
      this.scrollAnimationTimer = null;
    }
  },

  /**
   * 唱片旋转动画
   */
  startDiscRotation: function() {
    let rotation = this.data.discRotation || 0;
    
    this.rotationTimer = setInterval(() => {
      rotation += 0.5; // 每次旋转0.5度
      
      this.setData({
        discRotation: rotation
      });
    }, 50); // 每50ms执行一次
  },

  // 跳转到连接图谱页面
  goToConnectionMap: function() {
    wx.navigateTo({
      url: '/pages/connectionMap/connectionMap'
    });
  },

  // 跳转到成就系统页面
  goToAchievements: function() {
    wx.navigateTo({
      url: '/pages/achievements/achievements'
    });
  },

  // 跳转到社群报告页面
  goToFuzzySearch: function() {
    // 获取当前选中的主题信息
    const currentCard = this.data.cards[this.data.currentTrackIndex];
    const currentTheme = currentCard ? currentCard.name : '';
    const themeIndex = this.data.currentTrackIndex;
    
    console.log('当前选中的主题:', currentTheme, '索引:', themeIndex);
    
    wx.navigateTo({
      url: `/pages/briefing/briefing?theme=${encodeURIComponent(currentTheme)}&themeIndex=${themeIndex}`,
      fail: function(err) {
        console.error('跳转失败:', err);
        wx.showToast({
          title: '页面跳转失败',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 触摸开始事件
   */
  touchStart: function(e) {
    // 停止任何正在进行的惯性滚动
    if (this.data.inertiaAnimationId) {
      cancelAnimationFrame(this.data.inertiaAnimationId);
      this.setData({
        isInertiaScrolling: false,
        inertiaAnimationId: null
      });
    }
    
    const touch = e.touches[0];
    this.setData({
      startTouchY: touch.clientY,
      lastTouchY: touch.clientY,
      touchStartTime: Date.now(),
      isScrolling: true,
      isDragging: true
    });
  },

  /**
   * 添加振动反馈函数
   */
  vibrateFeedback: function() {
    // 调用微信小程序振动API
    wx.vibrateShort({
      type: 'light' // 轻微振动，适用于微信小程序基础库 2.13.0 及以上版本
    }).catch(error => {
      // 如果light类型不支持，回退到默认振动
      if (error) {
        wx.vibrateShort().catch(() => {
          // 忽略不支持振动的设备错误
          console.log('设备不支持振动');
        });
      }
    });
  },

  /**
   * 触摸移动事件
   */
  touchMove: function(e) {
    if (!this.data.isScrolling) return;
    
    const touch = e.touches[0];
    const currentY = touch.clientY;
    const deltaY = currentY - this.data.lastTouchY;
    
    // 计算滚动偏移量 - 降低滚动灵敏度，使滑动不至于太快
    const moveRate = 0.8; // 进一步降低滚动灵敏度
    const scrollDelta = deltaY * moveRate;
    let newScrollOffset = this.data.scrollOffset + scrollDelta;
    
    // 计算当前应该选中的卡片索引
    const itemCount = this.data.cards.length;
    if (itemCount > 0) {
      // 添加向上偏移量
      const cardPositionOffset = this.data.cardPositionOffset || -200; // 默认值为-200rpx
      
      // 添加边界限制，防止无限滚动
      const maxOffset = 0 + cardPositionOffset; // 顶部边界(加上偏移量)
      const minOffset = -(itemCount - 1) * this.data.itemHeight + cardPositionOffset; // 底部边界(加上偏移量)
      
      // 限制滚动范围
      if (newScrollOffset > maxOffset) {
        // 添加阻尼效果，使超出边界变得困难
        newScrollOffset = maxOffset + (newScrollOffset - maxOffset) * 0.2;
      } else if (newScrollOffset < minOffset) {
        // 添加阻尼效果，使超出边界变得困难
        newScrollOffset = minOffset + (newScrollOffset - minOffset) * 0.2;
      } else {
        // 在正常范围内，添加轻微磁吸效果
        // 计算最接近的项目中心
        const closestIndex = Math.round(-(newScrollOffset - cardPositionOffset) / this.data.itemHeight);
        const snapPoint = -closestIndex * this.data.itemHeight + cardPositionOffset;
        const distanceToSnap = Math.abs(newScrollOffset - snapPoint);
        
        // 当接近磁吸点时，轻微吸引
        const snapThreshold = this.data.itemHeight * 0.15;
        if (distanceToSnap < snapThreshold) {
          // 靠近磁吸点时，轻微拉向磁吸点
          const snapStrength = 0.3 * (1 - distanceToSnap / snapThreshold);
          newScrollOffset = newScrollOffset + (snapPoint - newScrollOffset) * snapStrength;
        }
      }
      
      // 根据偏移量计算索引(减去偏移量后计算)
      let newIndex = Math.round(-(newScrollOffset - cardPositionOffset) / this.data.itemHeight);
      
      // 确保索引在有效范围内
      newIndex = Math.max(0, Math.min(newIndex, itemCount - 1));
      
      // 记录当前索引用于比较
      const oldIndex = this.data.currentTrackIndex;
      
      // 更新数据
      this.setData({
        scrollOffset: newScrollOffset,
        lastTouchY: currentY,
        currentTrackIndex: newIndex
      });
      
      // 如果索引变化，触发振动反馈并同步主题到全局
      if (newIndex !== oldIndex) {
        this.vibrateFeedback();
        this.syncThemeToGlobal(newIndex);
      }
    } else {
      this.setData({
        scrollOffset: newScrollOffset,
        lastTouchY: currentY
      });
    }
  },
  
  /**
   * 处理循环滚动的索引计算
   */
  normalizeIndex: function(index, count) {
    if (count === 0) return 0;
    // 循环滚动：当索引小于0时，从列表末尾开始；当索引大于等于count时，从列表开头开始
    while (index < 0) {
      index += count;
    }
    return index % count;
  },

  /**
   * 触摸结束事件
   */
  touchEnd: function(e) {
    if (!this.data.isScrolling) return;
    
    const touchEndTime = Date.now();
    const touchDuration = touchEndTime - this.data.touchStartTime;
    
    // 计算滑动速度 (像素/毫秒)
    const touchDistance = this.data.lastTouchY - this.data.startTouchY;
    const velocity = touchDistance / touchDuration;
    
    // 设置结束状态
    this.setData({
      isScrolling: false,
      touchEndTime: touchEndTime,
      touchVelocity: velocity,
      isDragging: false
    });
    
    // 如果滑动速度很快，才使用惯性滚动，提高速度阈值
    if (Math.abs(velocity) > 0.2) {
      // 处理物理惯性滚动
      this.handleInertiaScroll(velocity);
    } else {
      // 速度较慢，直接对齐到最近的项目
      this.snapToClosestItem();
    }
  },
  
  /**
   * 处理惯性滚动
   */
  handleInertiaScroll: function(initialVelocity) {
    // 滚动速度太小则不启用惯性
    if (Math.abs(initialVelocity) < 0.05) {
      this.snapToClosestItem();
      return;
    }
    
    // 惯性参数 - 增加减速度，使滑动更快停下来
    const deceleration = 0.004; // 增加减速度
    let velocity = initialVelocity * 15; // 进一步降低初始速度系数
    let scrollOffset = this.data.scrollOffset;
    const itemCount = this.data.cards.length;
    const cardPositionOffset = this.data.cardPositionOffset || -200; // 默认值为-200rpx
    
    // 记录上一个索引，用于检测变化
    let lastIndex = this.data.currentTrackIndex;
    
    // 设置惯性滚动状态
    this.setData({
      isInertiaScrolling: true
    });
    
    // 使用定时器替代requestAnimationFrame
    const animate = () => {
      if (!this.data.isInertiaScrolling) return;
      
      if (Math.abs(velocity) > 0.1) {
        // 减速
        const direction = velocity > 0 ? 1 : -1;
        velocity -= direction * deceleration * 16; // 假设16ms为一帧
        
        // 计算滚动偏移
        const delta = velocity * 16;
        scrollOffset += delta;
        
        // 检查边界
        if (scrollOffset > 0 + cardPositionOffset) {
          scrollOffset = 0 + cardPositionOffset;
          velocity = 0; // 到达顶部边界，停止惯性
        } else if (scrollOffset < -(itemCount - 1) * this.data.itemHeight + cardPositionOffset) {
          scrollOffset = -(itemCount - 1) * this.data.itemHeight + cardPositionOffset;
          velocity = 0; // 到达底部边界，停止惯性
        }
        
        // 计算当前应该选中的卡片索引
        if (itemCount > 0) {
          let newIndex = Math.round(-(scrollOffset - cardPositionOffset) / this.data.itemHeight);
          
          // 确保索引在有效范围内
          newIndex = Math.max(0, Math.min(newIndex, itemCount - 1));
          
          // 增强磁吸效果 - 当接近某个选项的中心点时，增加减速
          const itemCenter = -newIndex * this.data.itemHeight + cardPositionOffset;
          const distanceToCenter = Math.abs(scrollOffset - itemCenter);
          const magnetThreshold = this.data.itemHeight * 0.4; // 磁吸范围
          
          if (distanceToCenter < magnetThreshold) {
            // 距离中心点越近，减速越明显
            const magnetStrength = 1 - (distanceToCenter / magnetThreshold);
            velocity *= (1 - (magnetStrength * 0.3)); // 使用磁吸强度减速
            
            // 如果速度很小且非常接近中心点，直接对齐并停止
            if (Math.abs(velocity) < 0.5 && distanceToCenter < this.data.itemHeight * 0.1) {
              this.setData({
                scrollOffset: itemCenter,
                currentTrackIndex: newIndex,
                isInertiaScrolling: false
              });
              return;
            }
          }
          
          // 检测索引是否变化
          if (newIndex !== lastIndex) {
            // 索引变化，触发振动反馈
            this.vibrateFeedback();
            // 更新上一个索引
            lastIndex = newIndex;
          }
          
          this.setData({
            scrollOffset: scrollOffset,
            currentTrackIndex: newIndex
          });
        } else {
          this.setData({
            scrollOffset: scrollOffset
          });
        }
        
        // 继续动画
        setTimeout(animate, 16);
      } else {
        // 速度太小，结束惯性滚动
        this.setData({
          isInertiaScrolling: false
        });
        
        // 对齐到最近的选项
        this.snapToClosestItem();
      }
    };
    
    // 启动动画
    setTimeout(animate, 16);
  },
  
  /**
   * 对齐到最近的选项
   */
  snapToClosestItem: function() {
    const itemCount = this.data.cards.length;
    if (itemCount === 0) return;
    
    // 计算最接近的项目索引
    const currentOffset = this.data.scrollOffset;
    const cardPositionOffset = this.data.cardPositionOffset || -200; // 默认值为-200rpx
    const rawIndex = Math.round(-(currentOffset - cardPositionOffset) / this.data.itemHeight);
    
    // 确保索引在有效范围内
    const newIndex = Math.max(0, Math.min(rawIndex, itemCount - 1));
    
    // 记录当前索引用于比较
    const oldIndex = this.data.currentTrackIndex;
    
    // 计算对齐后的偏移
    // 添加向上的位置偏移，使选中卡片位置更靠上
    const targetOffset = -newIndex * this.data.itemHeight + cardPositionOffset;
    
    // 如果当前偏移与目标偏移相差太大，使用动画过渡
    if (Math.abs(currentOffset - targetOffset) > 2) {
      this.animateToOffset(targetOffset, newIndex);
    } else {
      // 直接设置
      this.setData({
        scrollOffset: targetOffset,
        currentTrackIndex: newIndex
      });
      
      // 如果索引变化，触发振动反馈
      if (newIndex !== oldIndex) {
        this.vibrateFeedback();
      }
      
      // 自动选中当前项目（但不立即显示预览，只设置选中状态）
      this.setCurrentCardActive();
    }
  },
  
  /**
   * 动画滚动到指定偏移
   */
  animateToOffset: function(targetOffset, targetIndex) {
    const startOffset = this.data.scrollOffset;
    const distance = targetOffset - startOffset;
    const duration = 300;
    const startTime = Date.now();
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      if (elapsed >= duration) {
        // 动画结束
        this.setData({
          scrollOffset: targetOffset,
          currentTrackIndex: targetIndex,
          isInertiaScrolling: false
        });
        
        // 动画完成后选中当前项目
        this.setCurrentCardActive();
        return;
      }
      
      // 使用缓动效果
      const progress = this.easeOutQuint(elapsed / duration);
      const currentOffset = startOffset + distance * progress;
      
      this.setData({
        scrollOffset: currentOffset
      });
      
      // 继续动画
      setTimeout(animate, 16);
    };
    
    // 启动动画
    setTimeout(animate, 16);
  },
  
  /**
   * 平滑的二次方缓动函数
   */
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  
  /**
   * 更平滑的五次方缓动函数
   */
  easeOutQuint: function(t) {
    return 1 - Math.pow(1 - t, 5);
  },
  
  /**
   * 设置当前卡片为激活状态（不显示预览）
   */
  setCurrentCardActive: function() {
    if (this.data.cards.length === 0) return;
    
    // 获取当前选中的卡片索引
    const index = this.data.currentTrackIndex;
    
    // 只设置当前卡片为激活状态，不显示预览
    if (index >= 0 && index < this.data.cards.length) {
      // 什么都不做，因为active状态是通过视图层的class绑定自动设置的
      console.log('设置卡片激活状态:', index);
    }
  },

  /**
   * 点击查看主题详情 - 改为显示配对用户
   */
  viewTrackDetail: function(e) {
    const index = e.currentTarget.dataset.index;
    
    // 如果点击的项不是当前中心项，先滚动到该项
    if (index !== this.data.currentTrackIndex) {
      // 直接计算目标偏移量，添加向上偏移
      const cardPositionOffset = this.data.cardPositionOffset || -200;
      const targetOffset = -index * this.data.itemHeight + cardPositionOffset;
      
      // 使用动画滚动，然后显示配对用户
      this.animateToOffset(targetOffset, index);
      
      // 动画完成后显示配对用户
      setTimeout(() => {
        this.showPairedUsers(index);
      }, 300);
    } else {
      // 已经是中心项，直接显示配对用户
      this.showPairedUsers(index);
    }
  },
  
  /**
   * 显示配对用户
   */
  // 【重写】先检查是否已有配对，没有则AI配对
  showPairedUsers: function(index) {
    if (index < 0 || index >= this.data.cards.length) {
      console.error('主题索引无效:', index);
      return;
    }

    const theme = this.data.cards[index];
    const classifications = this.data.classifications;
    const currentUserOpenId = this.data.currentUserOpenId;

    console.log('=== 显示主题配对用户 ===');
    console.log('选中主题:', theme.name);
    console.log('当前用户openid:', currentUserOpenId);

    if (!classifications || !classifications.length) {
      wx.showToast({
        title: '社群数据未加载，请稍后重试',
        icon: 'none'
      });
      return;
    }

    if (!currentUserOpenId) {
      wx.showToast({
        title: '用户信息未获取，请稍后重试',
        icon: 'none'
      });
      return;
    }

    // 在classifications中找到对应的主题数据
    const themeData = classifications.find(t => t.theme === theme.name);
    if (!themeData || !themeData.communities) {
      console.log('未找到主题数据或社群数据:', theme.name);
      wx.showToast({
        title: `${theme.name}暂无社群数据`,
        icon: 'none'
      });
      return;
    }

    // 查找当前用户所在的社群
    let userCommunity = null;
    let communityMembers = [];

    for (const community of themeData.communities) {
      if (community.members) {
        const userInCommunity = community.members.find(member => member.openid === currentUserOpenId);
        if (userInCommunity) {
          userCommunity = community;
          // 获取除当前用户外的其他成员
          communityMembers = community.members.filter(member => member.openid !== currentUserOpenId);
          console.log('找到用户社群:', community.name, '其他成员数量:', communityMembers.length);
          break;
        }
      }
    }

    if (!userCommunity) {
      wx.showToast({
        title: `您在${theme.name}主题下还未被分配到社群`,
        icon: 'none',
        duration: 3000
      });
      return;
    }

    if (communityMembers.length === 0) {
      wx.showToast({
        title: `您的社群"${userCommunity.name}"中暂无其他成员`,
        icon: 'none',
        duration: 3000
      });
      return;
    }

    // 先检查是否已有配对
    this.checkExistingPairs(theme, userCommunity, communityMembers);
  },

  /**
   * 检查是否已有配对
   */
  checkExistingPairs: function(theme, userCommunity, communityMembers) {
    const currentUserOpenId = this.data.currentUserOpenId;
    
    console.log('=== 检查现有配对 ===');
    console.log('主题:', theme.name);
    console.log('社群:', userCommunity.name);
    
    wx.showLoading({
      title: '检查配对信息...',
    });

    // 查询connections集合
    const db = wx.cloud.database();
    db.collection('connections')
      .where({
        theme: theme.name,
        community: userCommunity.name
      })
      .get({
        success: (res) => {
          wx.hideLoading();
          console.log('connections查询结果:', res.data);
          
          if (res.data && res.data.length > 0) {
            // 查找包含当前用户的配对组
            const userPairGroup = res.data.find(group => 
              group.pairedUsers && group.pairedUsers.includes(currentUserOpenId)
            );
            
            if (userPairGroup) {
              console.log('找到现有配对组:', userPairGroup);
              
              // 获取配对用户的详细信息
              const pairedUserIds = userPairGroup.pairedUsers.filter(id => id !== currentUserOpenId);
              const pairedUsers = communityMembers.filter(member => 
                pairedUserIds.includes(member.openid)
              );
              
              console.log('配对的用户:', pairedUsers);
              
              // 显示配对用户
              this.showPairedUsersPreview(theme, userCommunity, pairedUsers, '已配对');
              return;
            }
          }
          
          // 没有找到配对，开始AI配对
          console.log('未找到现有配对，开始AI配对');
          this.requestAIPairing(theme, userCommunity, communityMembers);
        },
        fail: (err) => {
          wx.hideLoading();
          console.error('查询connections失败:', err);
          
          // 查询失败，仍然尝试AI配对
          console.log('查询失败，继续进行AI配对');
          this.requestAIPairing(theme, userCommunity, communityMembers);
        }
      });
  },

  /**
   * 请求AI配对
   */
  requestAIPairing: async function(theme, userCommunity, communityMembers) {
    const currentUserOpenId = this.data.currentUserOpenId;
    
    console.log('=== 开始AI配对 ===');
    console.log('社群成员数量:', communityMembers.length);
    
    if (communityMembers.length === 0) {
      wx.showToast({
        title: '社群中暂无其他成员可配对',
        icon: 'none'
      });
      return;
    }

    wx.showLoading({
      title: 'AI智能配对中...',
    });

    try {
      // 初始化云开发AI
      wx.cloud.init({
        env: "unionlink-4gkmzbm1babe86a7"
      });

      // 构建AI提示词
      const membersInfo = communityMembers.map(member => {
        const userInfo = member.userInfo || {};
        const responses = member.responses || {};
        
        return {
          openid: member.openid,
          昵称: userInfo.nickName || '未设置',
          问卷回答: responses
        };
      }).slice(0, 10); // 限制最多10个成员，避免prompt过长

      const prompt = `你是一个智能社交配对专家。请为用户在"${theme.name}"主题下的"${userCommunity.name}"社群中找到1-2位最适合的配对伙伴。

社群描述：${userCommunity.description || '无'}

社群成员信息：
${JSON.stringify(membersInfo, null, 2)}

请根据成员的问卷回答、兴趣爱好等信息，分析他们的兼容性和互补性，选择1-2位最适合配对的成员。

请严格按照以下JSON格式返回，不要添加任何其他文字：
{
  "pairedUsers": ["openid1", "openid2"],
  "reason": "配对理由，说明为什么这些用户适合配对"
}`;

      console.log('AI提示词:', prompt);

      // 创建模型并调用
      const model = wx.cloud.extend.AI.createModel("deepseek");
      const res = await model.generateText({
        model: "deepseek-v3-function-call",
        messages: [{ role: "user", content: prompt }],
      });

      console.log('AI返回原始结果:', res);

      // 解析AI返回结果
      let aiResult;
      try {
        // 获取AI返回的内容
        const aiContent = res.choices[0].message.content;
        console.log('AI返回内容:', aiContent);
        
        // 尝试解析JSON
        aiResult = JSON.parse(aiContent);
        console.log('解析后的AI结果:', aiResult);
      } catch (parseError) {
        console.error('解析AI返回结果失败:', parseError);
        throw new Error('AI返回结果格式异常');
      }

      if (!aiResult.pairedUsers || !Array.isArray(aiResult.pairedUsers)) {
        throw new Error('AI返回的配对用户格式异常');
      }

      // 验证配对用户是否存在
      const validPairedUsers = aiResult.pairedUsers.filter(openid => 
        communityMembers.some(member => member.openid === openid)
      );

      if (validPairedUsers.length === 0) {
        throw new Error('AI返回的配对用户无效');
      }

      console.log('有效的配对用户:', validPairedUsers);

      // 保存配对结果到云端
      await this.saveConnectionToCloud(theme, userCommunity, [currentUserOpenId, ...validPairedUsers], aiResult.reason);

      // 获取配对用户的详细信息
      const pairedUsers = communityMembers.filter(member => 
        validPairedUsers.includes(member.openid)
      );

      wx.hideLoading();

      // 显示配对结果
      this.showPairedUsersPreview(theme, userCommunity, pairedUsers, 'AI配对', aiResult.reason);

    } catch (error) {
      wx.hideLoading();
      console.error('AI配对失败:', error);
      
      wx.showModal({
        title: '配对失败',
        content: `AI配对过程中出现错误：${error.message}。是否显示社群所有成员？`,
        showCancel: true,
        confirmText: '显示所有成员',
        cancelText: '稍后重试',
        success: (res) => {
          if (res.confirm) {
            // 显示所有社群成员
            this.showPairedUsersPreview(theme, userCommunity, communityMembers, '社群成员');
          }
        }
      });
    }
  },

  /**
   * 保存配对结果到云端
   */
  saveConnectionToCloud: function(theme, userCommunity, pairedUsers, reason) {
    return new Promise((resolve, reject) => {
      console.log('=== 保存配对结果到云端 ===');
      console.log('主题:', theme.name);
      console.log('社群:', userCommunity.name);
      console.log('配对用户:', pairedUsers);
      console.log('配对理由:', reason);

      const db = wx.cloud.database();
      
      // 保存配对结果
      db.collection('connections').add({
        data: {
          theme: theme.name,
          community: userCommunity.name,
          pairedUsers: pairedUsers,
          reason: reason,
          createTime: new Date(),
          updateTime: new Date()
        },
        success: (res) => {
          console.log('配对结果保存成功:', res._id);
          resolve(res);
        },
        fail: (err) => {
          console.error('配对结果保存失败:', err);
          reject(err);
        }
      });
    });
  },

  /**
   * 显示配对用户预览
   */
  showPairedUsersPreview: function(theme, userCommunity, pairedUsers, pairType, reason) {
    console.log('=== 显示配对用户预览 ===');
    console.log('配对类型:', pairType);
    console.log('配对用户数量:', pairedUsers.length);
    console.log('配对理由:', reason);

    // 显示配对用户预览
    this.setData({
      showCardPreview: true,
      selectedCard: {
        ...theme,
        pairedUsers: pairedUsers,
        communityName: userCommunity.name,
        communityDescription: userCommunity.description,
        totalMembers: userCommunity.members.length,
        otherMembersCount: pairedUsers.length,
        pairType: pairType,
        pairReason: reason
      }
    });

    console.log('显示配对预览:', {
      主题: theme.name,
      社群: userCommunity.name,
      配对类型: pairType,
      配对用户数: pairedUsers.length
    });
  },

  /**
   * 查看用户名片
   */
  viewUserProfile: function(e) {
    const openid = e.currentTarget.dataset.openid;
    const user = this.data.communityMembers.find(u => u.openid === openid);
    if (user) {
      wx.navigateTo({
        url: `/pages/userProfile/userProfile?openid=${openid}`
      });
    }
  },

  /**
   * 显示主题详情
   */
  showCardDetail: function(index) {
    if (index >= 0 && index < this.data.cards.length) {
      const card = this.data.cards[index];
      this.setData({
        selectedCard: card,
        showCardPreview: true
      });
    }
  },
  
  /**
   * 关闭主题预览
   */
  closeCardPreview: function() {
    this.setData({
      showCardPreview: false
    });
  },

  /**
   * 初始化主题卡片数据
   */
  initThemeCards: function() {
    const themeCards = [
      {
        id: 1,
        name: "数码轨迹博物馆",
        subtitle: "Digital Trace Museum",
        description: "数码成长史 × 情怀 × 数字人格进化",
        theme: "数码轨迹博物馆",
        color: "#6366f1",
        avatarUrl: "https://api.dicebear.com/7.x/shapes/svg?seed=digital&backgroundColor=6366f1",
        details: {
          concept: "数码成长史 × 情怀 × 数字人格进化",
          features: ["🧑‍🚀 原始信号守望者", "🕹️ 掌上文明缔造者", "🌐 云端原居民", "🧭 设备极简主义者"],
          philosophy: "每一代设备，都是一段人生的缩影。"
        }
      },
      {
        id: 2,
        name: "感官沉浸研究所",
        subtitle: "Sensory Immersion Lab",
        description: "感官偏好 × 沉浸 × 体验风格",
        theme: "感官沉浸研究所",
        color: "#ec4899",
        avatarUrl: "https://api.dicebear.com/7.x/shapes/svg?seed=sensory&backgroundColor=ec4899",
        details: {
          concept: "感官偏好 × 沉浸 × 体验风格",
          features: ["🎨 视觉主义者", "🎧 声波感应者", "🤲 触觉掌控者", "🧠 思维沉浸者"],
          philosophy: "沉浸于感官，体验于心灵。"
        }
      },
      {
        id: 3,
        name: "行为方式匹配站",
        subtitle: "Behavior Match Station",
        description: "探索风格 × 好奇心 × 展会行动轨迹",
        theme: "行为方式匹配站",
        color: "#10b981",
        avatarUrl: "https://api.dicebear.com/7.x/shapes/svg?seed=behavior&backgroundColor=10b981",
        details: {
          concept: "探索风格 × 好奇心 × 展会行动轨迹",
          features: ["🚀 快速尝鲜玩家", "👓 信息观察者", "📷 内容创作者", "🛸 安静探索者"],
          philosophy: "每一种行为，都是独特的探索。"
        }
      },
      {
        id: 4,
        name: "能量节律星球",
        subtitle: "Energy Rhythm Planet",
        description: "作息偏好 × 星座 × MBTI × 状态映射",
        theme: "能量节律星球",
        color: "#f59e0b",
        avatarUrl: "https://api.dicebear.com/7.x/shapes/svg?seed=energy&backgroundColor=f59e0b",
        details: {
          concept: "作息偏好 × 星座 × MBTI × 状态映射",
          features: ["🌞 晨光规划者", "☀️ 午间聚能人", "🌌 夜间灵感族", "🌫️ 随境波动者"],
          philosophy: "节律不同，能量各异。"
        }
      }
    ];

    this.setData({
      cards: themeCards,
      isLoading: false
    });
  },

  /**
   * 获取交互用户名片 - 改为获取主题数据
   */
  getInteractionCards: function() {
    // 直接调用初始化主题卡片
    this.initThemeCards();
  },

  /**
   * 图片加载失败处理
   */
  onImageError: function(e) {
    const index = e.currentTarget.dataset.index;
    console.error(`主题图片加载失败，索引: ${index}`, e);
    
    // 获取当前主题卡片
    const card = this.data.cards[index];
    if (card) {
      console.log('加载失败的图片URL:', card.avatarUrl);
      
      // 可以在这里设置备用图片或清空URL
      // 简单将该卡片的头像URL设为空
      const newCards = [...this.data.cards];
      newCards[index].avatarUrl = '';
      
      this.setData({
        cards: newCards
      });
    }
  },
  
  /**
   * 图片加载成功处理
   */
  onImageLoad: function(e) {
    const index = e.currentTarget.dataset.index;
    console.log(`主题图片加载成功，索引: ${index}`);
  },

  /**
   * 设置触摸性能优化选项
   */
  setTouchPerfOptions: function() {
    // 设置wx.createSelectorQuery的性能选项
    if (wx.canIUse('createSelectorQuery.in')) {
      const query = wx.createSelectorQuery();
      
      // 尝试禁用滚动节流，提高流畅度
      if (query.in && query.in.scrollThrottle) {
        query.in({
          scrollThrottle: false
        });
      }
    }
    
    // 设置页面渲染层优化
    if (wx.canIUse('setPageStyle')) {
      wx.setPageStyle({
        style: {
          // 开启渲染新层优化
          'layer-performance-mode': 'fast'
        }
      }).catch(() => {
        // 忽略不支持的API错误
      });
    }
  },

  /**
   * 生成背景星星
   */
  generateStars() {
    const starCount = 50; // 星星数量
    let stars = [];
    
    for (let i = 0; i < starCount; i++) {
      // 随机位置和大小
      stars.push({
        id: i,
        x: Math.random() * 750, // 屏幕宽度为750rpx
        y: Math.random() * 1600, // 假设屏幕高度
        size: Math.random() * 4 + 1, // 星星大小1-5rpx
        opacity: Math.random() * 0.5 + 0.1, // 不透明度0.1-0.6
      });
    }
    
    this.setData({ stars });
  },

  /**
   * 初始化动画
   */
  initAnimation() {
    // 启动唱片旋转
    this.startDiscRotation();
    
    // 设置触摸性能优化，提高滚动流畅度
    this.setTouchPerfOptions();
    
    // 初始化主题预览相关数据
    this.setData({
      showCardPreview: false,
      selectedCard: {}
    });
  },

  /**
   * 同步主题索引到全局数据
   */
  syncThemeToGlobal: function(themeIndex) {
    const app = getApp();
    if (!app.globalData) {
      app.globalData = {};
    }
    app.globalData.currentThemeIndex = themeIndex;
    
    // 主题切换时重新加载社群成员
    this.loadCommunityMembers();
    
    console.log(`同步主题索引到全局: ${themeIndex}`);
  },

  // 【完全照抄briefing页面】调用云函数进行用户分类
  classifyUsers: function() {
    console.log('[ConnectPage] 开始分析社群...');
    wx.showLoading({
      title: '正在分析社群...',
    });

    // 调用云函数进行分类
    wx.cloud.callFunction({
      name: 'classifyUsers',
      data: {},
      success: res => {
        console.log('[classifyUsers] success:', res.result);
        // 分类成功后，从 class_bar 读取分类结果
        const db = wx.cloud.database();
        db.collection('class_bar').get({
          success: res => {
            console.log('从class_bar获取数据成功', res.data);
            console.log('class_bar原始数据结构检查:', res.data);
            
            // 根据README文档，数据结构应该是 res.data[0].data
            let classifications = [];
            if (res.data && res.data.length > 0 && res.data[0].data) {
              classifications = res.data[0].data;
              console.log('解析出的主题数组:', classifications);
            } else {
              console.error('class_bar数据结构不符合预期');
              classifications = res.data; // 降级处理
            }

            // 获取当前用户openid并重排序
            wx.cloud.callFunction({
              name: 'login',
              success: loginRes => {
                const openid = loginRes.result.openid;
                const reorderedClassifications = classifications.map(theme => {
                  theme.communities.forEach(community => {
                    const userIndex = community.members.findIndex(member => member.openid === openid);
                    if (userIndex > 0) {
                      const user = community.members.splice(userIndex, 1)[0];
                      community.members.unshift(user);
                    }
                    // 创建一个只包含前3个成员的数组用于显示
                    community.displayMembers = community.members.slice(0, 3);
                  });
                  return theme;
                });

                this.setData({
                  classifications: reorderedClassifications,
                  currentUserOpenId: openid
                });
                wx.hideLoading();
                
                console.log('[ConnectPage] 社群分析完成，数据已加载');
                // 成功后加载社群成员数据
                this.loadCommunityMembers();
              },
              fail: loginErr => {
                console.error('获取用户信息失败', loginErr);
                this.setData({ 
                  classifications,
                  currentUserOpenId: '' // 失败时清空
                });
                wx.hideLoading();
              }
            });
          },
          fail: err => {
            console.error('从class_bar获取数据失败', err);
            wx.hideLoading();
            wx.showToast({
              title: '获取社群数据失败',
              icon: 'none'
            });
          }
        });
      },
      fail: err => {
        console.error('[classifyUsers] fail:', err);
        wx.hideLoading();
        wx.showToast({
          title: '社群分析失败',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 获取当前主题下小分类的所有用户并AI配对 - 改为直接使用分类数据
   */
  getThemeUsersAndPair: async function() {
    // 直接使用已有的社群成员数据，不再重新AI配对
    this.loadCommunityMembers();
  },

  /**
   * 获取当前用户openid
   */
  getCurrentUserOpenid: function() {
    // 先尝试从缓存获取
    let openid = wx.getStorageSync('openid');
    console.log('从缓存获取的openid:', openid);
    
    if (openid) {
      this.setData({
        currentUserOpenid: openid
      });
      console.log('成功设置用户openid:', openid);
      return;
    }
    
    // 如果缓存没有，调用login云函数获取
    console.log('缓存中无openid，调用login云函数...');
    wx.cloud.callFunction({
      name: 'login',
      success: (res) => {
        console.log('login云函数返回结果:', res);
        if (res.result && res.result.openid) {
          openid = res.result.openid;
          this.setData({
            currentUserOpenid: openid
          });
          // 缓存openid
          wx.setStorageSync('openid', openid);
          console.log('成功获取并缓存openid:', openid);
          
          // 重新加载社群成员数据
          this.loadCommunityMembers();
        } else {
          console.error('login云函数返回数据异常:', res.result);
          wx.showToast({
            title: '获取用户信息失败',
            icon: 'none'
          });
        }
      },
      fail: (err) => {
        console.error('获取用户openid失败:', err);
        wx.showToast({
          title: '登录失败，请重试',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 加载分类数据
   */
  loadClassificationData: function() {
    const db = wx.cloud.database();
    
    console.log('开始加载分类数据...');
    // 显示加载提示
    wx.showLoading({
      title: '加载社群数据...',
      mask: true
    });
    
    // 从class_bar集合获取分类数据
    db.collection('class_bar').get({
      success: (res) => {
        wx.hideLoading();
        console.log('class_bar数据库查询结果:', res);
        
        if (res.data && res.data.length > 0) {
          // 获取第一条记录的data字段
          const classificationData = res.data[0].data || [];
          console.log('解析出的分类数据:', classificationData);
          
          this.setData({
            classificationData: classificationData
          });
          
          console.log('分类数据加载成功，共', classificationData.length, '个主题');
          
          // 加载当前主题的社群成员
          this.loadCommunityMembers();
        } else {
          console.log('class_bar集合为空或无数据');
          wx.showToast({
            title: '暂无社群数据，请先完成分类',
            icon: 'none',
            duration: 3000
          });
        }
      },
      fail: (err) => {
        wx.hideLoading();
        console.error('加载分类数据失败:', err);
        wx.showToast({
          title: '数据库连接失败',
          icon: 'none',
          duration: 3000
        });
      }
    });
  },

  /**
   * 【照抄briefing成功方案】根据当前主题加载社群成员
   */
  loadCommunityMembers: function() {
    const currentThemeIndex = this.data.currentTrackIndex;
    const currentTheme = this.data.cards[currentThemeIndex];
    const classifications = this.data.classifications; // 使用新的数据结构
    const currentUserOpenid = this.data.currentUserOpenId; // 使用新的字段名
    
    console.log('=== 【新版本】开始加载社群成员 ===');
    console.log('当前主题索引:', currentThemeIndex);
    console.log('当前主题:', currentTheme);
    console.log('分类数据长度:', classifications.length);
    console.log('当前用户openid:', currentUserOpenid);
    
    if (!currentTheme) {
      console.error('当前主题为空');
      return;
    }
    
    if (!classifications.length) {
      console.error('分类数据为空');
      wx.showToast({
        title: '请等待数据加载完成',
        icon: 'none'
      });
      return;
    }
    
    if (!currentUserOpenid) {
      console.error('用户openid为空');
      wx.showToast({
        title: '请稍后重试',
        icon: 'none'
      });
      return;
    }
    
               // 【调试】先查看实际的数据结构
      console.log('=== 调试信息 ===');
      console.log('classifications原始数据:', classifications);
      console.log('classifications长度:', classifications.length);
      if (classifications.length > 0) {
        console.log('classifications[0]结构:', classifications[0]);
        console.log('classifications[0]的keys:', Object.keys(classifications[0]));
      }
      
      // 【修正】classifications数组每个元素直接就是主题对象
      if (!classifications.length) {
        console.error('classifications数据为空');
        wx.showToast({
          title: '暂无分类数据',
          icon: 'none'
        });
        return;
      }
      
      console.log('可用主题列表:', classifications.map(t => t.theme));
      console.log('当前选择的主题名:', currentTheme.name);
      
      // 直接在classifications数组中匹配主题名称
      const themeData = classifications.find(theme => theme.theme === currentTheme.name);
    console.log('找到的主题数据:', themeData);
    
          if (!themeData || !themeData.communities) {
        console.log('未找到当前主题的社群数据:', currentTheme.name);
        console.log('可用的主题列表:', classifications.map(t => t.theme));
      this.setData({
        communityMembers: [],
        currentUserCommunity: null
      });
      wx.showToast({
        title: '该主题暂无社群数据',
        icon: 'none'
      });
      return;
    }
    
    console.log('主题社群数量:', themeData.communities.length);
    
    // 查找当前用户所在的社群
    let userCommunity = null;
    let communityMembers = [];
    
    for (let i = 0; i < themeData.communities.length; i++) {
      const community = themeData.communities[i];
      console.log(`检查社群 ${i + 1}:`, community.name, '成员数量:', community.members ? community.members.length : 0);
      
      if (community.members) {
        const userInCommunity = community.members.find(member => {
          console.log('检查成员openid:', member.openid, '与当前用户:', currentUserOpenid);
          return member.openid === currentUserOpenid;
        });
        
        if (userInCommunity) {
          console.log('找到用户所在社群:', community.name);
          userCommunity = community;
          // 获取除了当前用户之外的其他成员
          communityMembers = community.members.filter(member => 
            member.openid !== currentUserOpenid
          );
          console.log('社群其他成员数量:', communityMembers.length);
          break;
        }
      }
    }
    
    console.log('当前用户社群:', userCommunity);
    console.log('社群其他成员:', communityMembers);
    
    this.setData({
      currentUserCommunity: userCommunity,
      communityMembers: communityMembers,
      myPairs: communityMembers // 复用原有的显示逻辑
    });
    
    if (!userCommunity) {
      wx.showToast({
        title: '您还未被分配到任何社群',
        icon: 'none',
        duration: 3000
      });
    } else {
      console.log('成功加载社群成员，社群:', userCommunity.name, '其他成员:', communityMembers.length);
    }
  },

  /**
   * 显示配对理由弹窗 - 改为显示社群信息
   */
  showPairModal: function(e) {
    const openid = e.currentTarget.dataset.openid;
    const user = this.data.communityMembers.find(u => u.openid === openid);
    const currentUserCommunity = this.data.currentUserCommunity;
    
    let modalContent = '';
    if (currentUserCommunity) {
      modalContent = `社群：${currentUserCommunity.name}\n\n描述：${currentUserCommunity.description}`;
      if (user && user.userInfo) {
        modalContent += `\n\n与 ${user.userInfo.nickName} 同属一个社群，你们有相似的特质和兴趣！`;
      }
    } else {
      modalContent = '暂无社群信息';
    }
    
    this.setData({
      showPairModal: true,
      pairModalContent: modalContent,
      pairModalUser: user
    });
  },
  closePairModal: function() {
    this.setData({ showPairModal: false });
  },

  /**
   * 显示详细名片
   */
  showDetailedCard: function(e) {
    const memberIndex = e.currentTarget.dataset.memberIndex;
    const selectedCard = this.data.selectedCard;
    
    if (!selectedCard.pairedUsers || memberIndex >= selectedCard.pairedUsers.length) {
      console.error('成员索引无效:', memberIndex);
      wx.showToast({
        title: '成员信息异常',
        icon: 'none'
      });
      return;
    }
    
    const selectedMember = selectedCard.pairedUsers[memberIndex];
    
    console.log('=== 显示详细名片 ===');
    console.log('成员索引:', memberIndex);
    console.log('选中成员:', selectedMember);
    
    this.setData({
      showDetailedCard: true,
      selectedMember: selectedMember
    });
    
    console.log('显示详细名片弹窗:', {
      用户昵称: selectedMember.userInfo?.nickName,
      用户openid: selectedMember.openid
    });
  },

  /**
   * 关闭详细名片弹窗
   */
  closeDetailedCard: function() {
    this.setData({
      showDetailedCard: false,
      selectedMember: {}
    });
  },

  /**
   * 发送消息（预留功能）
   */
  sendMessage: function(e) {
    const openid = e.currentTarget.dataset.openid;
    console.log('发送消息给用户:', openid);
    
    // 这里可以后续添加发送消息功能
    wx.showToast({
      title: '消息功能开发中',
      icon: 'none'
    });
  },

  /**
   * 查看社群详情（预留功能）
   */
  viewCommunity: function() {
    console.log('查看社群详情');
    
    // 可以跳转到社群详情页面或者显示更多信息
    wx.showToast({
      title: '社群详情功能开发中',
      icon: 'none'
    });
  }
})